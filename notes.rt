#preamble ()

defobj Part_Template () {
      • serveNextInLine ⇐ ϕ
}



⌈ *** composition time *** ⌉

defobj Eh () {
      • inq ⇐ #freshQueue ()
      • outq ⇐ #freshQueue ()
}

defn send (eh,port,obj) {
  #enqueue (eh.outq, make_mevent (port, obj))
}
defn inject (eh,port,obj) {
  #enqueue (eh.inq, make_mevent (port, obj))
}




**** notes ****

⌈ Sends a mevent on the given `port` with `data`, placing it on the output⌉
⌈ of the given component.⌉

defn send (eh,port,obj,causingMevent) {
    deftemp d ⇐ Datum ()
    d.v ⇐ obj
    d.clone ⇐ λ: obj_clone (d)
    d.reclaim ⇐ None
    mev ≡ make_mevent(port, d)
    put_output (eh, mev)
}





const PartBase = {
    container: null,
    inputQueue: [],
    outputQueue: [],
    send: function(portName, payload) {...},
    inject: function (portName, payload) {...},
    handleFirstMevent: function () {...},
};
const PartBase = {
    outermost: null,
    inputQueue: [],
    outputQueue: [],
    send: function(portName, payload) {
	if (this.outermost === null) {
	    this.outputQueue.push({ port: portName, data: payload });
	} else {
	    outermost.send (portName, payload);
        }
    },
    inject: function (portName, payload) {
	if (this.outermost === null) {
	    this.inputQueue.push ({port: portName, data: payload });
	} else {
	    outermost.inject (portName, payload);
	}
    },
    handleFirstMevent: function () {
	if (this.inputQueue.length > 0) {
	    this.handle (this.inputQueue.shift ());
	}
    }
};
defobj Part_Template () {
      • nextInLineHandler ⇐ ϕ

      • v ⇐ ϕ
      • clone ⇐ ϕ
      • reclaim ⇐ ϕ
      • other ⇐ ϕ ⌈ reserved for use on per-project basis⌉ 
}

